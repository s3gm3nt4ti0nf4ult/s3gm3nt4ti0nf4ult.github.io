<!doctype html><html lang=pl><head><title>PL: Misja Gynvaela PL012 czyli zip && crc32 cracking :: FoxtrotLabs — Tam gdzie bajty mówią dobranoc</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="**Tysiące zagrożeń małoprawdopodobnych sumuje się w zagrożenie bardzo prawdopodobne.** Bruce Schneier Wreszcie&amp;hellip; &amp;hellip; znalazłem trochę czasu, żeby nadgonić zaległości w misjach. Obecny tryb pracy niestety nie pozwala mi na zbyt częste i treściwe postowanie (&amp;hellip;tak obiecałem&amp;hellip; pamiętam). Ale udało mi się dorwać poprzednią misję z polskiego streamu. Moim zdaniem jest na tyle ciekawa, że warto ją przybliżyć. Zacznijmy, jak zwykle, od początku.
MISJA 012 goo.gl/kBeZex DIFFICULTY: ██████░░░░ [6/10] ┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅ Podczas przeszukiwania zdobytych dysków znaleźliśmy plik ZIP z hasłem."><meta name=keywords content="hacking"><meta name=robots content="noodp"><link rel=canonical href=https://foxtrotlabs.cc/pl/2017/10/pl-misja-gynvaela-pl012-czyli-zip-crc32-cracking/><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-148414315-1","auto"),ga("send","pageview"))</script><link rel=stylesheet href=https://foxtrotlabs.cc/assets/style.css><link rel=stylesheet href=assets/%25!s%28%3cnil%3e%29.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://foxtrotlabs.cc/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href><meta name=twitter:card content="summary"><meta name=twitter:creator content="foxtrot_charlie"><meta property="og:locale" content="pl"><meta property="og:type" content="article"><meta property="og:title" content="PL: Misja Gynvaela PL012 czyli zip && crc32 cracking :: FoxtrotLabs"><meta property="og:description" content="**Tysiące zagrożeń małoprawdopodobnych sumuje się w zagrożenie bardzo prawdopodobne.** Bruce Schneier Wreszcie&amp;hellip; &amp;hellip; znalazłem trochę czasu, żeby nadgonić zaległości w misjach. Obecny tryb pracy niestety nie pozwala mi na zbyt częste i treściwe postowanie (&amp;hellip;tak obiecałem&amp;hellip; pamiętam). Ale udało mi się dorwać poprzednią misję z polskiego streamu. Moim zdaniem jest na tyle ciekawa, że warto ją przybliżyć. Zacznijmy, jak zwykle, od początku.
MISJA 012 goo.gl/kBeZex DIFFICULTY: ██████░░░░ [6/10] ┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅ Podczas przeszukiwania zdobytych dysków znaleźliśmy plik ZIP z hasłem."><meta property="og:url" content="https://foxtrotlabs.cc/pl/2017/10/pl-misja-gynvaela-pl012-czyli-zip-crc32-cracking/"><meta property="og:site_name" content="PL: Misja Gynvaela PL012 czyli zip && crc32 cracking"><meta property="og:image" content><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:section" content="pl"><meta property="article:section" content="gynvaelstream"><meta property="article:section" content="ctf"><meta property="article:published_time" content="2017-10-21 00:00:00 +0000 UTC"></head><body><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=https://foxtrotlabs.cc/pl><div class=logo>foxtrotlabs-pl</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=https://foxtrotlabs.cc/pl/posts>posty</a></li><li><a href=https://foxtrotlabs.cc/>English side</a></li><li><a href=https://foxtrotlabs.cc/pl/about>o mnie</a></li><li><a href=https://github.com/s3gm3nt4ti0nf4ult>github</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=https://foxtrotlabs.cc/pl/posts>posty</a></li><li><a href=https://foxtrotlabs.cc/>English side</a></li><li><a href=https://foxtrotlabs.cc/pl/about>o mnie</a></li><li><a href=https://github.com/s3gm3nt4ti0nf4ult>github</a></li></ul></nav><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-148414315-1","auto"),ga("send","pageview"))</script></header><div class=content><div class=post><h1 class=post-title><a href=https://foxtrotlabs.cc/pl/2017/10/pl-misja-gynvaela-pl012-czyli-zip-crc32-cracking/>PL: Misja Gynvaela PL012 czyli zip && crc32 cracking</a></h1><div class=post-meta><span class=post-date>2017-10-21</span>
<span class=post-author>::
foxtrot_charlie</span></div><span class=post-tags>#<a href=https://foxtrotlabs.cc/pl/tags/pl/>pl</a>&nbsp;
#<a href=https://foxtrotlabs.cc/pl/tags/ctf/>ctf</a>&nbsp;
#<a href=https://foxtrotlabs.cc/pl/tags/security/>security</a>&nbsp;
#<a href=https://foxtrotlabs.cc/pl/tags/gynvaelstream/>gynvaelstream</a>&nbsp;
#<a href=https://foxtrotlabs.cc/pl/tags/hacking/>hacking</a>&nbsp;
#<a href=https://foxtrotlabs.cc/pl/tags/zip/>zip</a>&nbsp;
#<a href=https://foxtrotlabs.cc/pl/tags/crc32/>crc32</a>&nbsp;</span><div class=post-content><div><center>**Tysiące zagrożeń małoprawdopodobnych sumuje się w zagrożenie bardzo prawdopodobne.**</br></center><div style=text-align:right>Bruce Schneier</div><h3 id=wreszcie>Wreszcie&mldr;<a href=#wreszcie class=hanchor arialabel=Anchor>&#8983;</a></h3><p>&mldr; znalazłem trochę czasu, żeby nadgonić zaległości w misjach. Obecny tryb pracy niestety nie pozwala mi na zbyt częste i treściwe postowanie (&mldr;tak obiecałem&mldr; pamiętam). Ale udało mi się dorwać poprzednią misję z polskiego streamu. Moim zdaniem jest na tyle ciekawa, że warto ją przybliżyć. Zacznijmy, jak zwykle, od początku.</p><pre tabindex=0><code>MISJA 012            goo.gl/kBeZex                  DIFFICULTY: ██████░░░░ [6/10]
┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅┅

Podczas przeszukiwania zdobytych dysków znaleźliśmy plik ZIP z hasłem. Ponieważ
nie znamy hasła - a mamy powody przypuszczać, że jest bardzo dobrej jakości i nie
do zgadnięcia czy złamania - to postanowiliśmy zwrócić się do Ciebie z prośbą o
pomoc:

  goo.gl/zYoYiq

Powodzenia!

--

Odzyskaną wiadomość umieść w komentarzu pod tym video :)
Linki do kodu/wpisów na blogu/etc z opisem rozwiązania są również mile widziane!

P.S. Rozwiązanie zadania przedstawię na jednym z vlogów w okolicy dwóch tygodni.
</code></pre></br>### Zaczynamy!
Pod [tym linkiem](https://goo.gl/zYoYiq)\* znajduje się plik będący archiwum w formacie zip.<p><img data-sizes=auto data-src=https://foxtrotlabs.cc/pics/GLS012PL/file.png class=lazyload></p><p>Próba wypakowania kończy się:</p><p><img data-sizes=auto data-src=https://foxtrotlabs.cc/pics/GLS012PL/unziping.png class=lazyload></p><p>Pomimo wyraźnego odradzenia przez Gyna prób zgadywania hasła, nie byłbym sobą, gdybym jednak nie odpalił crackera:</p><p><img data-sizes=auto data-src=https://foxtrotlabs.cc/pics/GLS012PL/cracker.png class=lazyload></p><p>W tym czasie zacząłem szukać alternatywnego sposobu poznania zawartości 20 plików o rozszerzeniu <em>.txt</em>. W tym celu otworzyłem sobie archiwum za pomocą hexedytora. Co zwróciło moją uwagę, to rozmiary zawartości. Pliki przed zaszyfrowaniem, mają rozmiar maksymalnie 4 bajtów. Zaszyfrowane dane mają aż 16 bajtów. Po długim przeszukiwaniu sieci oraz lektury <a href=https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT>specyfikacji</a> nie udało mi się namierzyć jakiejś podatności w implementacji samego szyfrowania AESem. W związku z tym, że zadanie było ocenione na 6 pkt. na 10 możliwych, to chyba zacząłem szukać za daleko. Te 4 bajty nie dawały mi spokoju. Aż do chwili gdy po raz kolejny patrząc w hexedytor zauważyłem:</p><p><img data-sizes=auto data-src=https://foxtrotlabs.cc/pics/GLS012PL/hexeditordump.png class=lazyload></p><p><em><strong>CRC32!</strong></em> Ciekawe czy jest liczone przed czy po szyfrowaniu. Okazuje się, że suma kontrola wyliczana jest przed szyfrowaniem i kompresowaniem danych (co w sumie jest oczywiste i intuicyjne). Dodatkowo crc32 dla 4 bajtów nie ma kolizji, stąd możemy próbować odwrócić proces obliczania checksumy lub skorzystać z brutalnej mocy obliczeniowej CPU (dla ambitnych GPU) i znaleźć te znaki, dla których suma kontrolna się zgadza. Oczywiście najpierw wybrałem najprostsze rozwiązanie, czyli bruteforce. W tym celu skorzystałem z następującego skryptu (yay, Python ma bardzo dobry support zip files):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env python</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> zipfile
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> zlib
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> itertools
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> string
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>crack</span>(fn):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> itertools<span style=color:#f92672>.</span>product(list(string<span style=color:#f92672>.</span>printable), repeat<span style=color:#f92672>=</span>fn[<span style=color:#e6db74>&#39;size&#39;</span>]):
</span></span><span style=display:flex><span>        j <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span><span style=color:#f92672>.</span>join(i)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (zlib<span style=color:#f92672>.</span>crc32(bytes(j, <span style=color:#e6db74>&#39;utf-8&#39;</span>)) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xffffffff</span>) <span style=color:#f92672>==</span> fn[<span style=color:#e6db74>&#39;crc32&#39;</span>]:
</span></span><span style=display:flex><span>            print(<span style=color:#e6db74>&#34;file: </span><span style=color:#e6db74>{}</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>.</span>format(fn[<span style=color:#e6db74>&#39;name&#39;</span>], j))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> j
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;file: </span><span style=color:#e6db74>{}</span><span style=color:#ae81ff>\t\t</span><span style=color:#e6db74> crc32:</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>.</span>format(fn[<span style=color:#e6db74>&#39;name&#39;</span>], fn[<span style=color:#e6db74>&#39;crc32&#39;</span>]))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    z <span style=color:#f92672>=</span> zipfile<span style=color:#f92672>.</span>ZipFile(<span style=color:#e6db74>&#39;m012.zip&#39;</span>)
</span></span><span style=display:flex><span>    fs <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> z<span style=color:#f92672>.</span>infolist():
</span></span><span style=display:flex><span>        fs<span style=color:#f92672>.</span>append({<span style=color:#e6db74>&#39;name&#39;</span>: i<span style=color:#f92672>.</span>filename, <span style=color:#e6db74>&#39;crc32&#39;</span>: i<span style=color:#f92672>.</span>CRC, <span style=color:#e6db74>&#39;size&#39;</span>: i<span style=color:#f92672>.</span>file_size})
</span></span><span style=display:flex><span>    flag <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#pool = Pool(processes=4)</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#for fn in pool.map(crack, fs):</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#    print(fn)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> fn <span style=color:#f92672>in</span> fs:
</span></span><span style=display:flex><span>        flag <span style=color:#f92672>+=</span> crack(fn)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;And the flag is: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>.</span>format(flag))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    main()
</span></span></code></pre></div><p>Kod jest mega prosty. W funkcji <code>main</code> dodaje do listy dane, które są potrzebne podczas &ldquo;zgadywania&rdquo; CRC32, czyli rozmiar (liczba bajtów) nieskompresowanego pliku oraz sama suma kontrolna. Dodatkowo zapamiętuje nazwę pliku, po to aby było wiadomo jakim znakom odpowiadają poszczególne pliki, gdyby kolejność miała znaczenie. Poznanie szczegółów archiwum zip umożliwia biblioteka zipfile oraz obiekt <code>ZipFile</code>. W szczególności metoda <code>infolist()</code>. Następnie w funkcji <code>crack</code>, każdy ciąg o długości równej rozmiarowi dokumentu txt, jest poddawany operacji obliczania CRC32. Jeżeli wartości się zgadzają, to kończymy zabawę i zwracamy tego stringa. Początkowo popełniłem błąd i zamiast iloczynu karteziańskiego wstawiłem permutację. Jak wiadomo <code>itertools.permutations</code> zwraca permutacje bez powtórzeń. Stąd słowa takie jak <strong>*too*</strong> lub <strong>*away*</strong> nie pojawiły się w rozwiązaniu i końcowa flaga wyglądała trochę dziwnie. Po zamianie na <code>itertools.product</code> otrzymałem poprawne (chyba, w końcu wszystkie znaki są printowalne i nawet mają sens) rozwiązanie:</p><pre tabindex=0><code>file: secrets/	
file: secrets/000.txt	And 
file: secrets/001.txt	I wo
file: secrets/002.txt	uld 
file: secrets/003.txt	have
file: secrets/004.txt	 got
file: secrets/005.txt	ten 
file: secrets/006.txt	away
file: secrets/007.txt	 wit
file: secrets/008.txt	h it
file: secrets/009.txt	 too
file: secrets/010.txt	, if
file: secrets/011.txt	 it 
file: secrets/012.txt	were
file: secrets/013.txt	n&#39;t 
file: secrets/014.txt	for 
file: secrets/015.txt	you 
file: secrets/016.txt	medd
file: secrets/017.txt	ling
file: secrets/018.txt	 kid
file: secrets/019.txt	s an
file: secrets/020.txt	d yo
file: secrets/021.txt	ur C
file: secrets/022.txt	RC32
file: secrets/023.txt	!
And the flag is: And I would have gotten away with it too, if it weren&#39;t for you meddling kids and your CRC32!
</code></pre><p>I to by było na tyle. Oczekiwanie na rozwiązanie trwało ponad 8 minut. Na CTFie taki czas pewnie by mnie satysfakcjonował. W końcu działa. Ale nie jest to optymalny sposób na poradzenie sobie z problemem. Poniżej przedstawiam moje próby przyspieszenia odzyskiwania zawartości plików.</p><h3 id=optymalizacja>Optymalizacja<a href=#optymalizacja class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Zasada numer 1 każdego CTFa brzmi: <strong>1. Jeśli napisałeś skrypt w Pythonie i działa za wolno - użyj pypy</strong> *. Posiadam <code>pypy</code> w tej <strong>jedynej i prawdziwej</strong> wersji czyli 2.x. Co za tym idzie musiałem dokonać drobnej zmiany w linijce 12 czyli tam, gdzie używamy &ldquo;bytes&rdquo; z racji innego handlingu stringów, bajtów etc. niż w rodzinie języka 3.x. Postać zmienionej formuły wygląda następująco:</p><p><code>if (zlib.crc32(bytes(j)) & 0xffffffff) == fn['crc32']:</code></p><p>Powinno wystarczyć. Zmierzyłem wykonanie za pomocą funkcji <code>time.time()</code>. Wynik jest bardziej zadowalający. Zamiast 8 minut czekałem już tylko ~180 sekund czyli 3 minuty (thanx captain obvious!). Jest progres.</p><p><img data-sizes=auto data-src=https://foxtrotlabs.cc/pics/GLS012PL/solved_12pl_pypy.png class=lazyload></p><p>Kolejnym naturalnym krokiem optymalizacji zadania, będzie wykorzystanie wielu wątków. Znaczy tak by było w języku typu C++. W przypadku Pythona, a przynajmniej wzorcowej implementacji cPythona i posiadającego JIT pypy istnieje coś takiego jak <em>GIL</em> czyli <a href=https://wiki.python.org/moin/GlobalInterpreterLock>&ldquo;global interpreter lock&rdquo;</a>. To nic innego jak mutex, który dba o to, aby w danym momencie tylko jeden proces maszyny wirtualnej wykonywał instancję bajtkodu. Co to znaczy? W cPythonie, za pomocą &ldquo;threads&rdquo; nie wykonamy obliczeń równolegle na oddzielnych rdzeniach CPU. Szkoda, bo to jest to na czym nam zależy. Oczywiście istnieją rozwiązania pośrednie jak Jython czy IronPython, które GILa nie posiadają. Tak samo może on zostać pominięty podczas wykonywania natywnego kodu C (notabene to się dzieje podczas korzystania z bibliotek takich jak zlib czy hashlib). Ale ja nie chcę pisać w C/C++, chcę w Pythonie! &lt;powiedział foxtrot i tupnął nogą>. Co więc nam zostaje?<br>Z pomocą przychodzi biblioteka <a href=https://docs.python.org/3.6/library/multiprocessing.html>multiprocessing</a>. Już sama nazwa wskazuje, że nie mamy doczynienia z <strong>threadami</strong> tylko <strong>procesami</strong>. To rozwiązanie dedykowane do obejścia, w pewnym stopniu, obecności GILa.<br>Aby skorzystać z klasy Pool, musiałem trochę przemodelować wejściowy solver. Można też ręcznie podzielić pulę CRC i odpalić kilka instancji interpretera. Wolę jednak rozwiązanie automatyczne. Schedluer zna się na swojej pracy na tyle, że nie będę mu narzucał swoich konwencji.
Kod nowej wersji wygląda tak:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e>#!/usr/bin/env python</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> zipfile
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> zlib
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> itertools
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> string
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> multiprocessing <span style=color:#66d9ef>as</span> mp
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> time <span style=color:#f92672>import</span> time
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>crack</span>(crc32, s):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> itertools<span style=color:#f92672>.</span>product(list(string<span style=color:#f92672>.</span>printable), repeat<span style=color:#f92672>=</span>s):
</span></span><span style=display:flex><span>        j <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span><span style=color:#f92672>.</span>join(i)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (zlib<span style=color:#f92672>.</span>crc32(bytes(j, <span style=color:#e6db74>&#39;utf-8&#39;</span>)) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xffffffff</span>) <span style=color:#f92672>==</span> crc32:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> j
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    z <span style=color:#f92672>=</span> zipfile<span style=color:#f92672>.</span>ZipFile(<span style=color:#e6db74>&#39;m012.zip&#39;</span>)
</span></span><span style=display:flex><span>    fs <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> z<span style=color:#f92672>.</span>infolist():
</span></span><span style=display:flex><span>        fs<span style=color:#f92672>.</span>append((i<span style=color:#f92672>.</span>CRC, int(i<span style=color:#f92672>.</span>file_size)))
</span></span><span style=display:flex><span>    pool <span style=color:#f92672>=</span> mp<span style=color:#f92672>.</span>Pool(processes<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span>    k <span style=color:#f92672>=</span> pool<span style=color:#f92672>.</span>starmap(crack, fs)
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;And the flag is: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>.</span>format(<span style=color:#e6db74>&#39;&#39;</span><span style=color:#f92672>.</span>join(k)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> __name__ <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;__main__&#39;</span>:
</span></span><span style=display:flex><span>    t0 <span style=color:#f92672>=</span> time()
</span></span><span style=display:flex><span>    main()
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;Duration: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>.</span>format(time() <span style=color:#f92672>-</span> t0))
</span></span></code></pre></div><p>Bingo! Czas wykonania na 4 rdzeniach wynosi już tylko 140s, co daje trochę ponad 2 minuty. Mamy rekordzistę na razie. Zużycie procesora po odpaleniu tego <strong>*cough*</strong> potwora <strong>*cough*</strong>:</p><p><img data-sizes=auto data-src=https://foxtrotlabs.cc/pics/GLS012PL/solver_12pl_mp_cpu_usage.png class=lazyload></p><p>Minusem tego rozwiązania jest obniżona responsywność systemu. Czuć lekkie obciążenie procesami typu CPU-bound. Co się zmieniło? Starmap wywołuje funkcje crack z jej dwoma parametrami. Przy czym <code>Pool</code> procesów wynosi 4. Co za tym idzie 4 instancje Pythona jednocześnie (równolegle) łamią 4 różne CRC. Zgodnie z dokumentacją <code>map</code> jak i <code>starmap</code> zwrócą wartości w kolejności odpalania procesów (co nie znaczy, że w kolejności ich zakończenia). Procesy startowały według kolejności plików, gdyby tak nie było potrzebowałbym dodatkowego argumentu, indeksu informującego o kolejności przetworzonej liczby (lub musiałbym zgadywać kolejność wyjścia, co już mniej mi się podoba). Nieuszeregowane wyniki można (przy delikatnie zwiększonej wydajności) otrzymać za pomocą <code>Pool.imap_unordered</code>. Kolejną opcją wykonania współbieżnego jest startowanie <code>x</code> procesów, które przetwarzać będą to samo CRC, ale od zaczną od różnych wartości. Po złamaniu jednej sumy, wszystkie <code>x</code> workerów kończy działanie i wystartowane zostają następne <code>x</code> workery z kolejnym CRC.</p><p>Ostatnią możliwością na jaką wpadłem było &ldquo;odwrócenie&rdquo; wartości CRC32. Nie jest to kryptograficzna funkcja skrótu i wydaje się, że dla maksymalnie 4 bajtowych wartości powinno obyć się bez problemu. Okazuje, że da się to zrobić. <a href=http://www.danielvik.com/2010/10/calculating-reverse-crc.html>Tutaj</a> znajduje się szerokie objaśnienie problemu. Jak na zadanie CTFowe, obracanie CRC32 w tym wypadku wydaje się zbyt pracochłonne do samodzielnej implementacji. Aczkolwiek posiłkując się SAT solverami jak z3, może udałoby się dojść do szybkiego i bezbolesnego rozwiązania. Moim zdaniem jest to nieopłacalne. Pierwsze rozwiązanie zajęło mi 10 minut pisania kodu (+ wcześniejsze zapoznanie się z sytuacją i standardem) + 8 minut wykonania. W przypadku reversowania CRC trwałoby to znacznie dłużej. Jeśli kogoś interesowałby temat, to polecam lekturę i dostępne toolsy:</p><ol><li><a href=https://blog.affien.com/archives/2005/07/15/reversing-crc/>https://blog.affien.com/</a></li><li><a href=http://stigge.org/martin/pub/SAR-PR-2006-05.pdf>White paper</a></li><li><a href=https://github.com/theonlypwner/crc32>CRC32 tool</a></li><li><a href=https://md5hashing.net/hash/crc32/0c2652fb>md5hashing.net - CRC32 cracker</a></li></ol><hr><p>*Druga zasada brzmi:<br><strong>2. Jeśli pypy nie daje rady nawet z multiprocessingiem to przepisz do do C++, zoptymalizuj co się da, dodaj openmp i odpal to na wypasionym AWS <wersja hard gpu></strong>;-).</p><hr><p>* Podziękowania dla użytkownika @marbel82 za korektę linku!</p></div></div><link rel=stylesheet href=https://foxtrotlabs.cc/comments.css><section class=post-comments><script src=https://www.google.com/recaptcha/api.js></script><h1 id=Comments>Comments<a href=#Comments class=hanchor arialabel=Anchor>&#8983;</a></h1><font size=1>My comments operate on free Heroku instance. If there is no traffic in 30 minutes the dyno service goes asleep. That causes a small delay in submitting your comment. Thank you for your patience ;)</font><p>Nothing yet.</p><h3>Say something</h3><form class=post-new-comment method=post action=https://flabs-staticman.herokuapp.com/v2/entry/s3gm3nt4ti0nf4ult/page_source/master/comments><input type=hidden name=options[redirect] value=https://foxtrotlabs.cc/pl/2017/10/pl-misja-gynvaela-pl012-czyli-zip-crc32-cracking/#comment-submitted>
<input type=hidden name=options[entryId] value=1868b682eb3175f2d04e977427a81377>
<input name=fields[name] type=text class=post-comment-field placeholder="Your name">
<input name=fields[email] type=email class=post-comment-field placeholder="Your email address">
<textarea name=fields[body] class=post-comment-field placeholder="Your message. Feel free to use Markdown." rows=10></textarea>
<input type=hidden name=options[reCaptcha][siteKey] value=6Lco6bkZAAAAAPwhdzJftINmETZymWpv1s8w1hKR>
<input type=hidden name=options[reCaptcha][secret] value="cNVL1K9Iu23KHkq4nAvjE8jFHYmFb1aJmvpOSSILJdZaUA07HolAG0UkqYzekmBKkxqNo4bAwKcPhGtIohOKp+PfBROWHhB+Vl+lGYQ9Z3+MTghdzhAZEC0V+Ti0WEvpfTXR7Lj6LUXwPNg+HRMj3/oYlou6vsz0cP1OSLPe9iMd4ZMGolwIaUowvWn9DVfU0eHKLAWUNXVRxFiBGcTKKbAd0JgR4ZtZs1VsPkhC3OlOsHm/yW2pA491SAQ0s820p+H1SncOd1kYE1h2gTL+oklzH+5CNz2V4xyq6Et4NLjinr0WGUN87eCFYUz+05wyEp+5lrG+uuq1eX2cBcfVoA=="></div><input type=submit class="post-comment-field btn" value=Submit><div class=g-recaptcha data-sitekey=6Lco6bkZAAAAAPwhdzJftINmETZymWpv1s8w1hKR></div></form></section><div id=comment-submitted class=dialog><h3>Thank you</h3><p>Your comment has been submitted and will be published once it has been approved.</p><p><a href=# class=btn>OK</a></p></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><span>copyright by foxtrot_charlie</span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://foxtrotlabs.cc/assets/main.js></script>
<script src=https://foxtrotlabs.cc/assets/prism.js></script></div></body></html>